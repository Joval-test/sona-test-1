# Workflow for Release Repository
# File: .github/workflows/propagate-issue.yml
name: Propagate Issue to Submodules
on:
  issues:
    types: [labeled, closed, reopened]
  issue_comment:
    types: [created]

jobs:
  create-submodule-issue:
    if: github.event_name == 'issues' && github.event.action == 'labeled'
    runs-on: ubuntu-latest
    steps:
      - name: Check if label matches a repository
        id: check-label
        run: |
          LABEL="${{ github.event.label.name }}"
          
          # Define direct submodules (top-level)
          DIRECT_REPOS=("ai" "backend" "interview-release" "email-handler-release")
          
          # Define nested submodules with their parent repositories
          # Format: "nested-repo:parent-repo"
          declare -A NESTED_MAP=(
            ["interview-core"]="interview-release"
            ["interview-ui"]="interview-release"
            ["email-sender"]="email-handler-release"
            ["email-templates"]="email-handler-release"
          )
          
          # Check if label matches any direct repo
          MATCHED=false
          TARGET_REPO=""
          PARENT_REPO=""
          IS_NESTED=false
          
          for repo in "${DIRECT_REPOS[@]}"; do
            if [[ "$LABEL" == "$repo" ]]; then
              MATCHED=true
              TARGET_REPO="$repo"
              break
            fi
          done
          
          # Check if label matches any nested repo
          if [[ "$MATCHED" == "false" ]]; then
            for nested_repo in "${!NESTED_MAP[@]}"; do
              if [[ "$LABEL" == "$nested_repo" ]]; then
                MATCHED=true
                TARGET_REPO="$nested_repo"
                PARENT_REPO="${NESTED_MAP[$nested_repo]}"
                IS_NESTED=true
                break
              fi
            done
          fi
          
          echo "matched=$MATCHED" >> $GITHUB_OUTPUT
          echo "target_repo=$TARGET_REPO" >> $GITHUB_OUTPUT
          echo "parent_repo=$PARENT_REPO" >> $GITHUB_OUTPUT
          echo "is_nested=$IS_NESTED" >> $GITHUB_OUTPUT
      
      - name: Create issue in target repository
        if: steps.check-label.outputs.matched == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SUBMODULE_PAT }}
          script: |
            const targetRepo = '${{ steps.check-label.outputs.target_repo }}';
            const parentRepo = '${{ steps.check-label.outputs.parent_repo }}';
            const isNested = '${{ steps.check-label.outputs.is_nested }}' === 'true';
            const owner = context.repo.owner;
            const originalIssue = context.payload.issue;
            
            // Determine the display path
            let displayPath = targetRepo;
            
            if (isNested && parentRepo) {
              displayPath = `${parentRepo}/${targetRepo}`;
            }
            
            // Construct the issue body with reference to original issue
            const issueBody = `${originalIssue.body || 'No description provided'}
            
            ---
            *This issue was automatically created from [${context.repo.repo}#${originalIssue.number}](${originalIssue.html_url})*
            **Linked Release Issue: #${originalIssue.number}**
            ${isNested ? `**Repository Path: ${displayPath}**` : ''}
            
            <!-- RELEASE_SYNC: ${context.repo.repo}:${originalIssue.number} -->`;
            
            try {
              const response = await github.rest.issues.create({
                owner: owner,
                repo: targetRepo,
                title: originalIssue.title,
                body: issueBody,
                labels: originalIssue.labels
                  .map(label => label.name)
                  .filter(name => name !== targetRepo)
              });
              
              // Add a comment to the original issue with the link and tracking info
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: originalIssue.number,
                body: `‚úÖ Issue created in [${displayPath}#${response.data.number}](${response.data.html_url})
                
            <!-- SYNC_TRACKER: ${targetRepo}:${response.data.number} -->`
              });
              
              console.log(`Successfully created issue in ${displayPath}`);
            } catch (error) {
              console.error(`Failed to create issue in ${displayPath}:`, error);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: originalIssue.number,
                body: `‚ùå Failed to create issue in ${displayPath}. Error: ${error.message}\n\nPlease check the workflow logs for more details.`
              });
            }

  sync-submodule-status:
    if: github.event_name == 'issues' && (github.event.action == 'closed' || github.event.action == 'reopened')
    runs-on: ubuntu-latest
    env:
      RELEASE_REPO_NAME: 'main-release'  # ‚Üê EDIT THIS: Change to your actual release repo name
    steps:
      - name: Check for linked release issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SUBMODULE_PAT }}
          script: |
            const issue = context.payload.issue;
            const action = context.payload.action;
            const expectedReleaseRepo = process.env.RELEASE_REPO_NAME;
            
            // Extract release repo and issue number from the issue body
            const syncMatch = issue.body?.match(/<!-- RELEASE_SYNC: (.+?):(\d+) -->/);
            
            if (!syncMatch) {
              console.log('No linked release issue found in this submodule issue');
              return;
            }
            
            const releaseRepo = syncMatch[1];
            const releaseIssueNumber = parseInt(syncMatch[2]);
            const owner = context.repo.owner;
            
            // Verify this is from the expected release repo
            if (releaseRepo !== expectedReleaseRepo) {
              console.log(`Skipping: Issue linked to ${releaseRepo}, but expected ${expectedReleaseRepo}`);
              return;
            }
            
            console.log(`Found linked release issue: ${releaseRepo}#${releaseIssueNumber}`);
            
            try {
              // Get the release issue to check its current state
              const releaseIssue = await github.rest.issues.get({
                owner: owner,
                repo: releaseRepo,
                issue_number: releaseIssueNumber
              });
              
              // Get all comments to find sync trackers
              const comments = await github.rest.issues.listComments({
                owner: owner,
                repo: releaseRepo,
                issue_number: releaseIssueNumber
              });
              
              // Extract all linked submodule issues from comments
              const linkedIssues = [];
              for (const comment of comments.data) {
                const match = comment.body?.match(/<!-- SYNC_TRACKER: (.+?):(\d+):/g);
                if (match) {
                  match.forEach(m => {
                    const parts = m.match(/<!-- SYNC_TRACKER: (.+?):(\d+):/);
                    if (parts) {
                      linkedIssues.push({
                        repo: parts[1],
                        number: parseInt(parts[2])
                      });
                    }
                  });
                }
              }
              
              console.log(`Found ${linkedIssues.length} linked submodule issues`);
              
              // Check the status of all linked submodule issues
              const issueStatuses = await Promise.all(
                linkedIssues.map(async (linkedIssue) => {
                  try {
                    const subIssue = await github.rest.issues.get({
                      owner: owner,
                      repo: linkedIssue.repo,
                      issue_number: linkedIssue.number
                    });
                    return {
                      repo: linkedIssue.repo,
                      number: linkedIssue.number,
                      state: subIssue.data.state,
                      url: subIssue.data.html_url
                    };
                  } catch (error) {
                    console.error(`Failed to fetch ${linkedIssue.repo}#${linkedIssue.number}:`, error);
                    return null;
                  }
                })
              );
              
              const validStatuses = issueStatuses.filter(s => s !== null);
              const allClosed = validStatuses.every(s => s.state === 'closed');
              const closedCount = validStatuses.filter(s => s.state === 'closed').length;
              const totalCount = validStatuses.length;
              
              // If the current submodule issue was closed
              if (action === 'closed') {
                // Add comment to release issue
                await github.rest.issues.createComment({
                  owner: owner,
                  repo: releaseRepo,
                  issue_number: releaseIssueNumber,
                  body: `üîí Submodule issue [${context.repo.repo}#${issue.number}](${issue.html_url}) was closed. (${closedCount}/${totalCount} closed)`
                });
                
                // If all linked submodule issues are now closed, close the release issue
                if (allClosed && releaseIssue.data.state === 'open') {
                  await github.rest.issues.update({
                    owner: owner,
                    repo: releaseRepo,
                    issue_number: releaseIssueNumber,
                    state: 'closed'
                  });
                  
                  await github.rest.issues.createComment({
                    owner: owner,
                    repo: releaseRepo,
                    issue_number: releaseIssueNumber,
                    body: '‚úÖ All linked submodule issues are closed. Automatically closing this release issue.'
                  });
                  
                  console.log('All submodule issues closed - closed release issue');
                }
              } 
              // If the current submodule issue was reopened
              else if (action === 'reopened') {
                // Add comment to release issue
                await github.rest.issues.createComment({
                  owner: owner,
                  repo: releaseRepo,
                  issue_number: releaseIssueNumber,
                  body: `üîì Submodule issue [${context.repo.repo}#${issue.number}](${issue.html_url}) was reopened.`
                });
                
                // If the release issue is closed but a submodule issue was reopened, reopen it
                if (releaseIssue.data.state === 'closed') {
                  await github.rest.issues.update({
                    owner: owner,
                    repo: releaseRepo,
                    issue_number: releaseIssueNumber,
                    state: 'open'
                  });
                  
                  await github.rest.issues.createComment({
                    owner: owner,
                    repo: releaseRepo,
                    issue_number: releaseIssueNumber,
                    body: '‚ö†Ô∏è A linked submodule issue was reopened. Automatically reopening this release issue.'
                  });
                  
                  console.log('Submodule issue reopened - reopened release issue');
                }
              }
              
            } catch (error) {
              console.error('Failed to sync status:', error);
            }
